---
title: 563. 二叉树的坡度
date: 2021-11-18 13:51:24
tags: [二叉树, 深度优先搜索]
categories: 算法
---

[563. 二叉树的坡度 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/binary-tree-tilt/)

给定一个二叉树，计算 **整个树** 的坡度 。

一个树的 **节点的坡度**定义即为，该节点左子树的节点之和和右子树节点之和的 **差的绝对值** 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。

**整个树** 的坡度就是其所有节点的坡度之和。

<!--more-->

~~~ python
class Solution:
    def __init__(self):
        self.ans = 0

    def findTilt(self, root: TreeNode) -> int:
        self.dfs(root)
        return self.ans

    def dfs(self, node):
        if not node:
            return 0
        sum_left = self.dfs(node.left)
        sum_right = self.dfs(node.right)
        self.ans += abs(sum_left - sum_right)
        return sum_left + sum_right + node.val

~~~

### 思路和算法

根据题意，我们需要累计二叉树中所有结点的左子树结点之和与右子树结点之和的差的绝对值。因此，我们可以使用深度优先搜索，在遍历每个结点时，累加其左子树结点之和与右子树结点之和的差的绝对值，并返回以其为根结点的树的结点之和。

具体地，我们实现算法如下：

- 从根结点开始遍历，设当前遍历的结点为 $\textit{node}node$；
  遍历$ \textit{node}node $的左子结点，得到左子树结点之和$ \textit{sum\_left}sum_left$；
- 遍历 $\textit{node}node$ 的右子结点，得到右子树结点之和 $\textit{sum\_right}sum_right$；
- 将左子树结点之和与右子树结点之和的差的绝对值累加到结果变量 $\textit{ans}ans$；
- 返回以 $\textit{node}node$ 作为根结点的树的结点之和$\textit{sum\_left} + \textit{sum\_right} + \textit{node}.\textit{val}sum_left+sum_right+node.val$。

